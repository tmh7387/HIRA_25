{"ast":null,"code":"import { supabase } from './supabase';\n\n// Utility: Validate that required fields exist in the assessment object\nconst validateAssessment = assessment => {\n  return assessment.consequence_id && assessment.hazard && assessment.consequence;\n};\n\n// Function to fetch a consequence by its ID\nasync function findConsequence(consequence_id) {\n  const {\n    data,\n    error\n  } = await supabase.from('hira_consequences').select(`\n      id as consequence_id,\n      description,\n      current_controls,\n      hazard:hira_hazards!inner(\n        id as hazard_id,\n        description,\n        event:hira_events!inner(\n          id as event_id,\n          name\n        )\n      )\n    `).eq('id', consequence_id).single();\n  if (error) {\n    console.error('Error finding consequence:', error);\n    throw new Error(`Consequence not found for ID: ${consequence_id}`);\n  }\n  if (!data || !data.consequence_id) {\n    console.error('Invalid consequence data returned:', data);\n    throw new Error(`No valid consequence found for ID: ${consequence_id}`);\n  }\n  return data;\n}\n\n// Function to create or update a risk assessment\nasync function createOrUpdateAssessment(assessment, matrix_type) {\n  if (!validateAssessment(assessment)) {\n    console.error('Invalid assessment object:', assessment);\n    throw new Error('Please fill in all required fields for each assessment.');\n  }\n  const consequence = await findConsequence(assessment.consequence_id);\n\n  // Check for existing assessment\n  const {\n    data: existingAssessment,\n    error: fetchError\n  } = await supabase.from('hira_risk_assessments').select('*').eq('consequence_id', consequence.consequence_id).single();\n  if (fetchError && fetchError.code !== 'PGRST116') {\n    throw fetchError;\n  }\n  const assessmentData = {\n    consequence_id: consequence.consequence_id,\n    matrix_type: matrix_type,\n    probability: assessment.probability ? parseInt(assessment.probability) : null,\n    severity: assessment.severity || null,\n    likelihood: assessment.likelihood ? parseInt(assessment.likelihood) : null,\n    impact: assessment.impact ? parseInt(assessment.impact) : null,\n    tolerability: assessment.tolerability || null\n  };\n  let result;\n  if (existingAssessment) {\n    // Update existing assessment\n    const {\n      data,\n      error\n    } = await supabase.from('hira_risk_assessments').update(assessmentData).eq('id', existingAssessment.id).select().single();\n    if (error) throw error;\n    result = data;\n  } else {\n    // Create a new assessment\n    const {\n      data,\n      error\n    } = await supabase.from('hira_risk_assessments').insert(assessmentData).select().single();\n    if (error) throw error;\n    result = data;\n  }\n  return {\n    assessment_id: result.id,\n    consequence_id: consequence.consequence_id,\n    event: consequence.hazard.event.name,\n    hazard: consequence.hazard.description,\n    consequence: consequence.description,\n    current_controls: consequence.current_controls,\n    matrix_type: result.matrix_type,\n    probability: result.probability,\n    severity: result.severity,\n    likelihood: result.likelihood,\n    impact: result.impact,\n    tolerability: result.tolerability\n  };\n}\n\n// Function to create multiple assessments\nexport async function createAssessments(project_id, assessmentsData, matrix_type) {\n  var _assessmentsData$asse;\n  console.log('Creating assessments for project:', project_id);\n  if (!(assessmentsData !== null && assessmentsData !== void 0 && (_assessmentsData$asse = assessmentsData.assessments) !== null && _assessmentsData$asse !== void 0 && _assessmentsData$asse.length)) {\n    console.error('No assessments provided');\n    throw new Error('No assessments provided');\n  }\n\n  // Validate input data\n  assessmentsData.assessments.forEach((assessment, index) => {\n    if (!validateAssessment(assessment)) {\n      console.error(`Assessment ${index} is missing required fields:`, assessment);\n      throw new Error(`Please fill in all required fields for assessment ${index + 1}.`);\n    }\n  });\n  const assessmentPromises = assessmentsData.assessments.map(async assessment => {\n    return await createOrUpdateAssessment(assessment, matrix_type);\n  });\n  try {\n    const results = await Promise.all(assessmentPromises);\n    console.log('Successfully created all assessments:', results);\n    return {\n      assessments: results\n    };\n  } catch (error) {\n    console.error('Error creating assessments:', error);\n    throw error;\n  }\n}\n\n// Function to update assessments\nexport async function updateAssessments(project_id, assessmentsData, matrix_type) {\n  try {\n    console.log('Updating assessments for project:', project_id);\n    const {\n      data: existingAssessments,\n      error: fetchError\n    } = await supabase.from('hira_risk_assessments').select(`\n        id,\n        consequence:hira_consequences!inner(\n          hazard:hira_hazards!inner(\n            event:hira_events!inner(\n              project_id\n            )\n          )\n        )\n      `).eq('consequence.hazard.event.project_id', project_id);\n    if (fetchError) throw fetchError;\n    console.log('Found existing assessments:', existingAssessments);\n\n    // Delete existing assessments\n    if ((existingAssessments === null || existingAssessments === void 0 ? void 0 : existingAssessments.length) > 0) {\n      const {\n        error: deleteError\n      } = await supabase.from('hira_risk_assessments').delete().in('id', existingAssessments.map(a => a.id));\n      if (deleteError) throw deleteError;\n      console.log('Deleted existing assessments.');\n    }\n\n    // Create new assessments\n    return await createAssessments(project_id, assessmentsData, matrix_type);\n  } catch (error) {\n    console.error('Error updating assessments:', error);\n    throw error;\n  }\n}\n\n// Function to fetch assessments by project ID\nexport async function getAssessmentsByProjectId(project_id) {\n  try {\n    console.log('Getting assessments for project:', project_id);\n    const {\n      data,\n      error\n    } = await supabase.from('hira_risk_assessments').select(`\n        id,\n        matrix_type,\n        probability,\n        severity,\n        likelihood,\n        impact,\n        tolerability,\n        consequence:hira_consequences!inner(\n          id as consequence_id,\n          description,\n          current_controls,\n          hazard:hira_hazards!inner(\n            id as hazard_id,\n            description,\n            event:hira_events!inner(\n              id as event_id,\n              name,\n              project_id\n            )\n          )\n        )\n      `).eq('consequence.hazard.event.project_id', project_id);\n    if (error) throw error;\n    console.log('Fetched assessments:', data);\n    return data.map(assessment => ({\n      assessment_id: assessment.id,\n      consequence_id: assessment.consequence.consequence_id,\n      event: assessment.consequence.hazard.event.name,\n      hazard: assessment.consequence.hazard.description,\n      consequence: assessment.consequence.description,\n      current_controls: assessment.consequence.current_controls,\n      matrix_type: assessment.matrix_type,\n      probability: assessment.probability,\n      severity: assessment.severity,\n      likelihood: assessment.likelihood,\n      impact: assessment.impact,\n      tolerability: assessment.tolerability\n    }));\n  } catch (error) {\n    console.error('Error fetching assessments:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["supabase","validateAssessment","assessment","consequence_id","hazard","consequence","findConsequence","data","error","from","select","eq","single","console","Error","createOrUpdateAssessment","matrix_type","existingAssessment","fetchError","code","assessmentData","probability","parseInt","severity","likelihood","impact","tolerability","result","update","id","insert","assessment_id","event","name","description","current_controls","createAssessments","project_id","assessmentsData","_assessmentsData$asse","log","assessments","length","forEach","index","assessmentPromises","map","results","Promise","all","updateAssessments","existingAssessments","deleteError","delete","in","a","getAssessmentsByProjectId"],"sources":["C:/Users/tmh73/Aviation Synergy/MaXwell AI - General/HIRA_25/src/services/riskAssessmentService.js"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\n// Utility: Validate that required fields exist in the assessment object\r\nconst validateAssessment = (assessment) => {\r\n  return assessment.consequence_id && assessment.hazard && assessment.consequence;\r\n};\r\n\r\n// Function to fetch a consequence by its ID\r\nasync function findConsequence(consequence_id) {\r\n  const { data, error } = await supabase\r\n    .from('hira_consequences')\r\n    .select(`\r\n      id as consequence_id,\r\n      description,\r\n      current_controls,\r\n      hazard:hira_hazards!inner(\r\n        id as hazard_id,\r\n        description,\r\n        event:hira_events!inner(\r\n          id as event_id,\r\n          name\r\n        )\r\n      )\r\n    `)\r\n    .eq('id', consequence_id)\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error('Error finding consequence:', error);\r\n    throw new Error(`Consequence not found for ID: ${consequence_id}`);\r\n  }\r\n\r\n  if (!data || !data.consequence_id) {\r\n    console.error('Invalid consequence data returned:', data);\r\n    throw new Error(`No valid consequence found for ID: ${consequence_id}`);\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n// Function to create or update a risk assessment\r\nasync function createOrUpdateAssessment(assessment, matrix_type) {\r\n  if (!validateAssessment(assessment)) {\r\n    console.error('Invalid assessment object:', assessment);\r\n    throw new Error('Please fill in all required fields for each assessment.');\r\n  }\r\n\r\n  const consequence = await findConsequence(assessment.consequence_id);\r\n\r\n  // Check for existing assessment\r\n  const { data: existingAssessment, error: fetchError } = await supabase\r\n    .from('hira_risk_assessments')\r\n    .select('*')\r\n    .eq('consequence_id', consequence.consequence_id)\r\n    .single();\r\n\r\n  if (fetchError && fetchError.code !== 'PGRST116') {\r\n    throw fetchError;\r\n  }\r\n\r\n  const assessmentData = {\r\n    consequence_id: consequence.consequence_id,\r\n    matrix_type: matrix_type,\r\n    probability: assessment.probability ? parseInt(assessment.probability) : null,\r\n    severity: assessment.severity || null,\r\n    likelihood: assessment.likelihood ? parseInt(assessment.likelihood) : null,\r\n    impact: assessment.impact ? parseInt(assessment.impact) : null,\r\n    tolerability: assessment.tolerability || null\r\n  };\r\n\r\n  let result;\r\n  if (existingAssessment) {\r\n    // Update existing assessment\r\n    const { data, error } = await supabase\r\n      .from('hira_risk_assessments')\r\n      .update(assessmentData)\r\n      .eq('id', existingAssessment.id)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    result = data;\r\n  } else {\r\n    // Create a new assessment\r\n    const { data, error } = await supabase\r\n      .from('hira_risk_assessments')\r\n      .insert(assessmentData)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    result = data;\r\n  }\r\n\r\n  return {\r\n    assessment_id: result.id,\r\n    consequence_id: consequence.consequence_id,\r\n    event: consequence.hazard.event.name,\r\n    hazard: consequence.hazard.description,\r\n    consequence: consequence.description,\r\n    current_controls: consequence.current_controls,\r\n    matrix_type: result.matrix_type,\r\n    probability: result.probability,\r\n    severity: result.severity,\r\n    likelihood: result.likelihood,\r\n    impact: result.impact,\r\n    tolerability: result.tolerability\r\n  };\r\n}\r\n\r\n// Function to create multiple assessments\r\nexport async function createAssessments(project_id, assessmentsData, matrix_type) {\r\n  console.log('Creating assessments for project:', project_id);\r\n\r\n  if (!assessmentsData?.assessments?.length) {\r\n    console.error('No assessments provided');\r\n    throw new Error('No assessments provided');\r\n  }\r\n\r\n  // Validate input data\r\n  assessmentsData.assessments.forEach((assessment, index) => {\r\n    if (!validateAssessment(assessment)) {\r\n      console.error(`Assessment ${index} is missing required fields:`, assessment);\r\n      throw new Error(`Please fill in all required fields for assessment ${index + 1}.`);\r\n    }\r\n  });\r\n\r\n  const assessmentPromises = assessmentsData.assessments.map(async (assessment) => {\r\n    return await createOrUpdateAssessment(assessment, matrix_type);\r\n  });\r\n\r\n  try {\r\n    const results = await Promise.all(assessmentPromises);\r\n    console.log('Successfully created all assessments:', results);\r\n    return { assessments: results };\r\n  } catch (error) {\r\n    console.error('Error creating assessments:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Function to update assessments\r\nexport async function updateAssessments(project_id, assessmentsData, matrix_type) {\r\n  try {\r\n    console.log('Updating assessments for project:', project_id);\r\n\r\n    const { data: existingAssessments, error: fetchError } = await supabase\r\n      .from('hira_risk_assessments')\r\n      .select(`\r\n        id,\r\n        consequence:hira_consequences!inner(\r\n          hazard:hira_hazards!inner(\r\n            event:hira_events!inner(\r\n              project_id\r\n            )\r\n          )\r\n        )\r\n      `)\r\n      .eq('consequence.hazard.event.project_id', project_id);\r\n\r\n    if (fetchError) throw fetchError;\r\n\r\n    console.log('Found existing assessments:', existingAssessments);\r\n\r\n    // Delete existing assessments\r\n    if (existingAssessments?.length > 0) {\r\n      const { error: deleteError } = await supabase\r\n        .from('hira_risk_assessments')\r\n        .delete()\r\n        .in('id', existingAssessments.map(a => a.id));\r\n\r\n      if (deleteError) throw deleteError;\r\n      console.log('Deleted existing assessments.');\r\n    }\r\n\r\n    // Create new assessments\r\n    return await createAssessments(project_id, assessmentsData, matrix_type);\r\n  } catch (error) {\r\n    console.error('Error updating assessments:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Function to fetch assessments by project ID\r\nexport async function getAssessmentsByProjectId(project_id) {\r\n  try {\r\n    console.log('Getting assessments for project:', project_id);\r\n\r\n    const { data, error } = await supabase\r\n      .from('hira_risk_assessments')\r\n      .select(`\r\n        id,\r\n        matrix_type,\r\n        probability,\r\n        severity,\r\n        likelihood,\r\n        impact,\r\n        tolerability,\r\n        consequence:hira_consequences!inner(\r\n          id as consequence_id,\r\n          description,\r\n          current_controls,\r\n          hazard:hira_hazards!inner(\r\n            id as hazard_id,\r\n            description,\r\n            event:hira_events!inner(\r\n              id as event_id,\r\n              name,\r\n              project_id\r\n            )\r\n          )\r\n        )\r\n      `)\r\n      .eq('consequence.hazard.event.project_id', project_id);\r\n\r\n    if (error) throw error;\r\n\r\n    console.log('Fetched assessments:', data);\r\n\r\n    return data.map(assessment => ({\r\n      assessment_id: assessment.id,\r\n      consequence_id: assessment.consequence.consequence_id,\r\n      event: assessment.consequence.hazard.event.name,\r\n      hazard: assessment.consequence.hazard.description,\r\n      consequence: assessment.consequence.description,\r\n      current_controls: assessment.consequence.current_controls,\r\n      matrix_type: assessment.matrix_type,\r\n      probability: assessment.probability,\r\n      severity: assessment.severity,\r\n      likelihood: assessment.likelihood,\r\n      impact: assessment.impact,\r\n      tolerability: assessment.tolerability\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error fetching assessments:', error);\r\n    throw error;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}