{"ast":null,"code":"import { supabase } from './supabase';\nexport async function getHazardsByEventId(eventId) {\n  try {\n    const {\n      data: hazards,\n      error\n    } = await supabase.from('hira_hazards').select(`\n        id,\n        description,\n        hira_consequences (\n          id,\n          description,\n          current_controls\n        )\n      `).eq('event_id', eventId).order('created_at', {\n      ascending: true\n    });\n    if (error) {\n      console.error('Error fetching hazards:', error);\n      throw error;\n    }\n    return hazards.map(hazard => ({\n      uniqueId: hazard.id,\n      description: hazard.description,\n      consequences: hazard.hira_consequences.map(consequence => ({\n        uniqueId: consequence.id,\n        description: consequence.description,\n        currentControls: consequence.current_controls\n      }))\n    }));\n  } catch (error) {\n    console.error('Error getting hazards:', error);\n    throw error;\n  }\n}\nexport async function updateHazards(eventId, hazardsData) {\n  try {\n    // Update hazards using upsert to preserve IDs\n    const hazardsPromises = hazardsData.map(async hazard => {\n      // Upsert hazard\n      const {\n        data: updatedHazard,\n        error: hazardError\n      } = await supabase.from('hira_hazards').upsert({\n        id: hazard.uniqueId,\n        event_id: eventId,\n        description: hazard.description,\n        updated_at: new Date().toISOString()\n      }).select().single();\n      if (hazardError) {\n        console.error('Error upserting hazard:', hazardError);\n        throw hazardError;\n      }\n\n      // Upsert consequences\n      const consequencesPromises = hazard.consequences.map(consequence => supabase.from('hira_consequences').upsert({\n        id: consequence.uniqueId,\n        hazard_id: updatedHazard.id,\n        description: consequence.description,\n        current_controls: consequence.currentControls,\n        updated_at: new Date().toISOString()\n      }).select().single());\n      const consequencesResults = await Promise.all(consequencesPromises);\n      const consequences = consequencesResults.map(result => {\n        if (result.error) throw result.error;\n        return {\n          uniqueId: result.data.id,\n          description: result.data.description,\n          currentControls: result.data.current_controls\n        };\n      });\n      return {\n        uniqueId: updatedHazard.id,\n        description: updatedHazard.description,\n        consequences\n      };\n    });\n    const results = await Promise.all(hazardsPromises);\n    return results;\n  } catch (error) {\n    console.error('Error updating hazards:', error);\n    throw error;\n  }\n}\nexport async function deleteHazards(eventId) {\n  try {\n    const {\n      error\n    } = await supabase.from('hira_hazards').delete().eq('event_id', eventId);\n    if (error) throw error;\n  } catch (error) {\n    console.error('Error deleting hazards:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["supabase","getHazardsByEventId","eventId","data","hazards","error","from","select","eq","order","ascending","console","map","hazard","uniqueId","id","description","consequences","hira_consequences","consequence","currentControls","current_controls","updateHazards","hazardsData","hazardsPromises","updatedHazard","hazardError","upsert","event_id","updated_at","Date","toISOString","single","consequencesPromises","hazard_id","consequencesResults","Promise","all","result","results","deleteHazards","delete"],"sources":["C:/Users/tmh73/Aviation Synergy/MaXwell AI - General/HIRA_25/src/services/hazardService.js"],"sourcesContent":["import { supabase } from './supabase';\r\n\r\nexport async function getHazardsByEventId(eventId) {\r\n  try {\r\n    const { data: hazards, error } = await supabase\r\n      .from('hira_hazards')\r\n      .select(`\r\n        id,\r\n        description,\r\n        hira_consequences (\r\n          id,\r\n          description,\r\n          current_controls\r\n        )\r\n      `)\r\n      .eq('event_id', eventId)\r\n      .order('created_at', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching hazards:', error);\r\n      throw error;\r\n    }\r\n\r\n    return hazards.map(hazard => ({\r\n      uniqueId: hazard.id,\r\n      description: hazard.description,\r\n      consequences: hazard.hira_consequences.map(consequence => ({\r\n        uniqueId: consequence.id,\r\n        description: consequence.description,\r\n        currentControls: consequence.current_controls\r\n      }))\r\n    }));\r\n  } catch (error) {\r\n    console.error('Error getting hazards:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function updateHazards(eventId, hazardsData) {\r\n  try {\r\n    // Update hazards using upsert to preserve IDs\r\n    const hazardsPromises = hazardsData.map(async hazard => {\r\n      // Upsert hazard\r\n      const { data: updatedHazard, error: hazardError } = await supabase\r\n        .from('hira_hazards')\r\n        .upsert({\r\n          id: hazard.uniqueId,\r\n          event_id: eventId,\r\n          description: hazard.description,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (hazardError) {\r\n        console.error('Error upserting hazard:', hazardError);\r\n        throw hazardError;\r\n      }\r\n\r\n      // Upsert consequences\r\n      const consequencesPromises = hazard.consequences.map(consequence =>\r\n        supabase\r\n          .from('hira_consequences')\r\n          .upsert({\r\n            id: consequence.uniqueId,\r\n            hazard_id: updatedHazard.id,\r\n            description: consequence.description,\r\n            current_controls: consequence.currentControls,\r\n            updated_at: new Date().toISOString()\r\n          })\r\n          .select()\r\n          .single()\r\n      );\r\n\r\n      const consequencesResults = await Promise.all(consequencesPromises);\r\n      const consequences = consequencesResults.map(result => {\r\n        if (result.error) throw result.error;\r\n        return {\r\n          uniqueId: result.data.id,\r\n          description: result.data.description,\r\n          currentControls: result.data.current_controls\r\n        };\r\n      });\r\n\r\n      return {\r\n        uniqueId: updatedHazard.id,\r\n        description: updatedHazard.description,\r\n        consequences\r\n      };\r\n    });\r\n\r\n    const results = await Promise.all(hazardsPromises);\r\n    return results;\r\n  } catch (error) {\r\n    console.error('Error updating hazards:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function deleteHazards(eventId) {\r\n  try {\r\n    const { error } = await supabase\r\n      .from('hira_hazards')\r\n      .delete()\r\n      .eq('event_id', eventId);\r\n\r\n    if (error) throw error;\r\n  } catch (error) {\r\n    console.error('Error deleting hazards:', error);\r\n    throw error;\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}